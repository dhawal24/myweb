// In Javascript, functions are treated like objects, hence they are also called "First class functions"

// Function assignment
var greetings = function(name) {
 console.log("Hello " + name + "!");
}
greetings("Apollo");

// Callback: Sample #1: Getting notified once a time taking operation is done
// Here the anonymous function passed to readingFromDatabase as an argument
// will be called once the function call is complete

// Sleeps or Delays the execution of main thread for a specified interval
function sleep(interval) {
 var beginTime = new Date().getTime();
 while (new Date().getTime() < beginTime + interval);
}

// A dummy database read call, which takes 3 secs to complete
// Once the read is successfull, the callback is getting invoked
function readingFromDatabase(callback) {
 sleep(3000);
 callback();
}

// Some peice of code, to replicate the reald world scenario
function doSomething() {
 readingFromDatabase(function() {
  console.log("Read successfull!");
 });
 console.log("This statement, will be executed soon after call the readingFromDatabase function!");
 console.log("The callback is a one to one communication mechanism!");
}

// Function Nesting -- There is no limit to the number of nested functions
function parent() {
 function child() {
  function grandChild() {
  }
 }
}

// Closure -- Each function has its own scope and a reference to the parent scope
// The example below demonstrates the scope inheritance or flow of scope from parent to child
// This flow of scope or scope inheritance is called Closure
function parent() {
 var name = "Alok";
 if(typeof name != "undefined") {
  console.log("Scope[Parent] --> Name: " + name);
 }
 if(typeof childName != "undefined") {
  console.log("Scope[Parent] --> ChildName: " + childName);
 }
 if(typeof grandChildName != "undefined") {
  console.log("Scope[Parent] --> GrandChildName: " + grandChildName);
 }

 function child() {
  var childName = "Apollo";
  if(typeof name != "undefined") {
   console.log("Scope[Child] --> Name: " + name);
  }
  if(typeof childName != "undefined") {
   console.log("Scope[Child] --> ChildName: " + childName);
  }
  if(typeof grandChildName != "undefined") {
   console.log("Scope[Child] --> GrandChildName: " + grandChildName);
  }

  function grandChild() {
   var grandChildName = "Durvesh";
   if(typeof name != "undefined") {
    console.log("Scope[GrandChild] --> Name: " + name);
   }
   if(typeof childName != "undefined") {
    console.log("Scope[GrandChild] --> ChildName: " + childName);
   }
   if(typeof grandChildName != "undefined") {
    console.log("Scope[GrandChild] --> GrandChildName: " + grandChildName);
   }
  }
  grandChild();
 }
 child();
}

// Function as return type
// The example below is a demonstration of function nesting, function as return type and closure
function parent() {
 var name = "Lakshmi";
 function child() {
  // Due to principle of closure, the variable name is accessible inside child function
  console.log(name);
 }
 return child;
}

var fn = parent();
fn(); // The fn now points to the child function created inside the parent function

// Due to principle of closure, the variable name is accessible inside child function,
// hence the result below

// "Lakshmi"













